import json
import networkx as nx
from collections import defaultdict
import shutil
import os
from gemd.util.impl import recursive_foreach

_encoder = None
_subdirpath = None


def out(item):
    '''
    function object to run on individual item during recursion 
    :param item: json item to write its destination 
    '''
    fn = '_'.join([item.__class__.__name__, item.name, item.uids['auto']])
    with open(os.path.join(_subdirpath, fn),'w') as fp :
        fp.write(_encoder.thin_dumps(item,indent=3))
        
def plot_graph(dirpath, mode='run'):
    '''
    creates a NetworkX graph representation of the GEMD relationships by reading every object
    generated by the GEMDEncoder object, storing all of its links by uid, and forming directed relationships, 
    such as ingredient->process, or process->material
    It then allows filtering the objects mapped (i.e., removing spec or runs, 
    measurements or ingredients) and saves a NetworkX graph in "dot" as .png
    
    :param dirpath: source of graph 
    :param mode: to plot a graph of specs, runs or templates
    '''
    G = nx.DiGraph()
    mapping = defaultdict()
    nb_disregarded = 0
    gemd_objects = [os.path.join(dirpath, f) for f in os.listdir(dirpath)]
    for obj in gemd_objects:
        fp =  open(obj, 'r')
        obj_data = json.load(fp)
        # print(obj_data['type'])
        # print(obj_data['name'])
        obj_type = obj_data['type']
        if obj_type.startswith('parameter') or obj_type.startswith('condition') or obj_type.startswith('property'):
            nb_disregarded +=1
            continue
        uid = obj_data['uids']['auto']
        name = obj_data['name']
        mapping[uid] = name
        if obj_type.startswith('process'):
            if obj_type.endswith(mode):
                G.add_node(uid, color='red')
        elif obj_type.startswith('ingredient'): # if node doesn't exist, create?
            if obj_type.endswith(mode):
                G.add_node(uid, color='blue')
                process = obj_data['process']['id']
                material = obj_data['material']['id']
                G.add_edge(uid, process)
                G.add_edge(material, uid)
        elif obj_type.startswith('material'):
            if obj_type.endswith(mode):
                if obj_data['process']:
                    process = obj_data['process']['id']
                G.add_node(uid, color='green')
                G.add_edge(process, uid)
        elif obj_type.startswith('measurement'):
            if obj_type.endswith(mode):
                print("found measurement!")
                material = obj_data['material']['id']
                G.add_node(uid, color='yellow')
                G.add_edge(uid, material)
                
            
    G_bis = nx.nx_agraph.to_agraph(G)
    G_bis.layout(prog="dot")
    uid_path = os.path.join(dirpath, '{}_uid_graph.png'.format(mode))
    G_bis.draw(uid_path)
    
    relabeled_G = nx.relabel_nodes(G, mapping)
    G_bis = nx.nx_agraph.to_agraph(relabeled_G)
    G_bis.layout(prog="dot")
    info_path = os.path.join(dirpath, '{}_name_graph.png'.format(mode))
    G_bis.draw(info_path)
   
    print("cycles in the graph: {}".format(list(nx.simple_cycles(G))))
    print("nb of disregarded elements (i.e., templates/specs): {}/{}".format(nb_disregarded, len(gemd_objects)))
    return uid_path, info_path

def test(encoder, subdirpath, terminal_gemd_obj, mode):
    '''
    runs a series of tests on a set of GEMD objects. It starts by writing them to 
    subdirpath using a recursive function on the terminal gemd object in your worklow, 
    and custom plots a graph of GEMD objects.
    :param encoder: GEMDencoder object of the current run
    :param subdirpath: destination directory of your GEMD objects tied to a run
    :param terminal_gemd_obj: last gemd object in the pipeline/workflow 
    :param mode: determins what object type to plot
    '''
    # delete if it already exists
    if os.path.exists(subdirpath):
        shutil.rmtree(subdirpath)
    os.mkdir(subdirpath)
    global _subdirpath
    _subdirpath = subdirpath
    global _encoder
    _encoder = encoder
    encoder.thin_dumps(terminal_gemd_obj,indent=3) # this step needs to be run to instantiate
    recursive_foreach(terminal_gemd_obj, out)
    return plot_graph(subdirpath, mode=mode)